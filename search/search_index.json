{"config":{"lang":["en"],"separator":"[\\s\\-]+"},"docs":[{"title":"VISU - A Modern Game Framework for PHP","text":"<p>VISU is a component based php game engine. Think Laravel or Symfony, but for game development.</p> <p>This framework is built around the extension PHP-GLFW which is requried for VISU to work.</p>","location":"index.html"},{"title":"Core Philosophy","text":"","location":"index.html#core-philosophy"},{"title":"Replace what you want, keep what you need","text":"<p>VISU is built around the idea of modularity. You can replace any system you want with your own implementation, while keeping the rest of the framework intact.</p> <ul> <li>Most parts of VISU are decoupled by design and don't require the entire framework stack to work. If you want to use our rendering helpers go ahead.</li> <li>There is no fixed rendering pipeline, you can freely extend or replace the existing rendering systems with your own.</li> </ul>  <ul> <li> <p> Install in 5 minutes</p>  <p>If you haven't installed PHP-GLFW yet, follow the installation guide for your platform.</p>  <p> Installation</p> </li> <li> <p> PHP GameDev Tutorial</p>  <p>Everything ready to get started? Jump right into the tutorial on writing games with PHP.</p>  <p> Getting Started</p> </li> <li> <p> PHP OpenGL Tutorial</p>  <p></p> <p>Want to first understand the core? Checkout the tutorial on writing OpenGL applications with PHP.</p> <p>This is not a VISU tutorial, but it will help you understand the core concepts of OpenGL, which  will help you develop better games with VISU.</p>  <p> Getting Started (PHP-GLFW)</p> </li> <li> <p> Examples &amp; Games</p>  <p></p> <p>There is a small collection of examples and games available to get you started.</p>  <p> Games</p> </li> </ul>","location":"index.html#replace-what-you-want-keep-what-you-need"},{"title":"API Reference","text":"","location":"api-reference.html"},{"title":"docs-assets","text":"<p>This repository is used to store the PHP-GLFW and VISU documentation assets. To not bloat the main repos.</p>","location":"docs-assets/index.html"},{"title":"A list of PHP Games","text":"<p>A list of games written in PHP, with VISU and PHP-GLFW. Example code is a great way to learn how to use a framework, and having examples at hand how to solve difficult problems. </p> <p>The list is still small but Im looking forward to see it grow.</p>  <p>Did you build a PHP Game?</p> <p>Have you build something with PHP-GLFW or VISU? Let us know and we will add it to the list. </p> <p>We absolutely love to see your creations!</p> <p>Just open a Pull Request on GitHub and add your game to the list.</p>","location":"games/0-php-games.html"},{"title":"PHP Games","text":"Name Type Image     FlappyPHPant 2D    PHP Towerdefense 3D     <p> </p>","location":"games/0-php-games.html#php-games"},{"title":"FlappyPHPant","text":"<p>  </p>  <ul> <li> <p> FlappyPHPant Game</p>  <p>A very simple Flappy Bird-like game written in PHP, built on PHP-GLFW and the VISU framework.</p>  <p> GitHub</p> <p> Download</p> </li> </ul>","location":"games/flappyphpant.html"},{"title":"Story","text":"<p>You are an elephant with wings, and you have to fly through the pipes... </p>","location":"games/flappyphpant.html#story"},{"title":"Features","text":"<ul> <li>Jump</li> <li>Die</li> </ul>","location":"games/flappyphpant.html#features"},{"title":"Controls","text":"<ul> <li>Press <code>space</code> to jump.</li> <li>Press <code>R</code> to reset.</li> <li>Press <code>F1</code> to disable the profiler and the debug overlay.    Note: the profiler takes a huge toll on performance as it forces the GPU to sync with the CPU after each render pass.</li> </ul>","location":"games/flappyphpant.html#controls"},{"title":"PHP Towerdefense","text":"<ul> <li> <p> PHP Towerdefense Game</p>  <p>A simple 3D tower defense game written in PHP, using PHP-GLFW and the VISU framework.</p>  <p> GitHub</p> <p> Download</p> </li> </ul>","location":"games/phptowerdefense.html"},{"title":"Features","text":"<ul> <li>Billboard progress bars</li> <li>Level serialization</li> <li>RTS / Citybuilder like camera system</li> <li>Keyboard and Mouse input event system</li> <li>alot more stuff.</li> </ul>","location":"games/phptowerdefense.html#features"},{"title":"Screenshots &amp; Gifs","text":"<p>Basic level editor:</p> <p></p> <p>Model drag n drop</p> <p></p>","location":"games/phptowerdefense.html#screenshots-gifs"},{"title":"Installation & Requirements","text":"<p>Is PHP-GLFW already installed?</p>","location":"getting-started/installation.html"},{"title":"If you've already installed <code>PHP-GLFW</code>, the Project Setup Guide is what you're looking for.","text":"<p>To install and use VISU, you'll need a few things:</p> <ul> <li>PHP 8.1 or higher</li> <li>Composer</li> <li>PHP-GLFW</li> </ul> <p>In this guide, we'll quickly go over each of these requirements. Feel free to skip any of these steps if you already have them installed.</p>","location":"getting-started/installation.html#if-youve-already-installed-php-glfw-the-project-setup-guide-is-what-youre-looking-for"},{"title":"PHP","text":"<p>VISU requires PHP 8.1 or a higher version. If you haven't installed PHP yet:</p> <ul> <li>Download it from the official PHP website.</li> <li>Alternatively, you can use your favorite package manager (<code>brew</code>, <code>apt</code>, etc.) to get it.</li> </ul> <p>Do keep in mind the version requirement. VISU won't function with older PHP editions. To check your PHP version, execute <code>php -v</code> in your terminal.</p>","location":"getting-started/installation.html#php"},{"title":"Docker","text":"<p>Docker is not supported</p> <p>PHP-GLFW requires access to an active display server and cannot run inside Docker containers. please install and run PHP-GLFW natively on Linux, macOS, or Windows.</p>","location":"getting-started/installation.html#docker"},{"title":"Composer","text":"<p>VISU uses Composer to manage its dependencies. If you don't have Composer installed yet, you can download it from the official Composer website.</p>","location":"getting-started/installation.html#composer"},{"title":"PHP-GLFW","text":"<p>VISU is built entirely around PHP-GLFW and requires it to be installed. PHP-GLFW is a PHP extension that provides bindings for GLFW and OpenGL, allowing you to create and manage windows, OpenGL contexts, and handle input events, etc.</p> <p>PHP-GLFW is supported on Linux, macOS, and Windows. You can find installation instructions for your operating system below:</p> <ul> <li>Linux Installation</li> <li>macOS Installation</li> <li>Windows Installation</li> </ul>","location":"getting-started/installation.html#php-glfw"},{"title":"Installing VISU","text":"<p>As VISU is a framework for PHP its installation is done via Composer. To create a new VISU project follow the next setps:</p> <p>Project Setup \u2192</p>","location":"getting-started/installation.html#installing-visu"},{"title":"Project Setup","text":"<p>Setting up a new VISU PHP Game Project.</p>  <p>Is PHP-GLFW already installed?</p> <p>Have you read the installation guide yet? If not, please do so first. VISU requires the following:</p> <ul> <li>PHP 8.1 or higher</li> <li>Composer</li> <li>PHP-GLFW</li> </ul> <p>Follow the installation guide if you haven't installed the extensions yet!</p>","location":"getting-started/project-setup.html"},{"title":"Creating a new VISU project","text":"","location":"getting-started/project-setup.html#creating-a-new-visu-project"},{"title":"Pick your Setup","text":"<p>VISU can be setup in multiple different ways, for the sake of simplicity we are going to focus on two main methods:</p> <ol> <li> <p>\ud83d\ude80 VISU Quickstart (Recommended for beginners)          The VISU Quickstart creates a minimal and lightweight VISU application for rapid prototyping.</p> </li> <li> <p>\u26a1 Full VISU Starter Project (Advanced)          The VISU Starter Project creates a fully featured VISU application with basic game structure, asset management, and example code. (Think like a framework with controllers, routing, views, etc.)</p> </li> </ol> <p>Once you have all the requirements installed, you can create a new VISU project using Composer's <code>create-project</code>.</p>","location":"getting-started/project-setup.html#pick-your-setup"},{"title":"VISU Quickstart","text":"<p>You can find the VISU Quickstart repository here.</p>  <p></p>  <p>To create a new VISU Quickstart project, run the following Composer command in your terminal:</p> <pre><code>composer create-project phpgl/visu-quickstart -s dev --prefer-dist my-php-game\n</code></pre> <p>This command will create a new VISU project in the <code>my-php-game</code> directory.</p> <p>Then enter the newly created project in your terminal:</p> <pre><code>cd my-php-game\n</code></pre> <p>And you're ready to go!</p> <pre><code>php bin/start.php\n</code></pre>  <p></p>  <p>You should see a window open with a black background and red ball that you can move around with \"WASD\" keys.</p>","location":"getting-started/project-setup.html#visu-quickstart"},{"title":"Quickstart Structure","text":"<pre><code>my-php-game/\n\u251c\u2500\u2500 app.ctn        &lt;- App Configuration / Dependency Container\n\u251c\u2500\u2500 bootstrap.php  &lt;- Bootstrap / Initialization File\n\u251c\u2500\u2500 composer.json\n\u251c\u2500\u2500 app/           &lt;- Additional configuration / dependencies\n\u251c\u2500\u2500 bin/           &lt;- Executable scripts\n\u251c\u2500\u2500 src/           &lt;- Your game code\n\u2502   \u2514\u2500\u2500 Application.php\n\u251c\u2500\u2500 var/           &lt;- Writable directory for logs, cache, etc.\n\u2514\u2500\u2500 vendor/        &lt;- Composer dependencies\n</code></pre>","location":"getting-started/project-setup.html#quickstart-structure"},{"title":"Full VISU Starter Project","text":"<p>You can find the VISU Starter Project repository here.</p> <p>To create a new VISU Starter project, run the following Composer command in your terminal:</p> <pre><code>composer create-project phpgl/visu-starter -s dev --prefer-dist my-php-game\n</code></pre> <p>This command will create a new VISU project in the <code>my-php-game</code> directory.</p> <p>There's a quick wizard that might ask you for a few basics, like your game's name, to create the initial configuration.</p> <p>After the installation, open the newly created project in your terminal:</p> <pre><code>cd my-php-game\n</code></pre>","location":"getting-started/project-setup.html#full-visu-starter-project"},{"title":"Running the game","text":"<p>Once all dependencies are installed, you can run the game by executing the <code>play</code> command:</p> <pre><code>./bin/play\n</code></pre> <p>A window should open with a black background and a few flying elephpants in it.</p>  <p> </p> VISU Starter Project Screen","location":"getting-started/project-setup.html#running-the-game"},{"title":"Controls","text":"<p>The controls of the VISU PHP starter game are as follows:</p> <ul> <li>W - Move up</li> <li>A - Move left</li> <li>S - Move down</li> <li>D - Move right</li> <li>F1 - Toggle debug text and profiler</li> <li>ctrl+c - Toggles the ingame console</li> <li>ESC - Exit the game</li> </ul>","location":"getting-started/project-setup.html#controls"},{"title":"VertexArrays (Basic)","text":"<p>VISU's <code>BasicVertexArray</code> gives you a clean, high-level way to define and render simple vertex data in OpenGL. It removes the boilerplate of creating VAOs/VBOs and wiring up attributes.</p>","location":"user-guide/graphics/basic-vertex-array.html"},{"title":"Introduction","text":"<p>In OpenGL, a Vertex Array Object (VAO) records how your vertex attributes are read, while a Vertex Buffer Object (VBO) holds the raw vertex data. <code>BasicVertexArray</code> packages those pieces into a simple API that:</p> <ul> <li>lets you declare a float-only layout (for example <code>[3, 2]</code> for <code>vec3</code> position + <code>vec2</code> UV)</li> <li>calculates stride and byte offsets for you</li> <li>sets up attribute pointers in the correct order</li> <li>provides simple bind-and-draw helpers</li> </ul>  <p>Note</p> <p><code>BasicVertexArray</code> is intentionally float-only. If you need integer or byte attributes, normalized values, indexed drawing (element buffers), or instancing, use raw OpenGL functions directly or one of VISU's specialized helpers instead.</p>","location":"user-guide/graphics/basic-vertex-array.html#introduction"},{"title":"Creating a BasicVertexArray","text":"<p>To create a <code>BasicVertexArray</code>, you need an instance of <code>GLState</code> and a vertex layout definition. The vertex layout is specified as an array of integers, where each integer represents the number of floats for that attribute.</p> <pre><code>use VISU\\Graphics\\BasicVertexArray;\n\n// resolve your global GL state (for example from the container)\n$glState = $container-&gt;resolveGL();\n\n// create a vertex array with a simple layout\n// [3, 2] = vec3 position + vec2 texture coordinates = 5 floats per vertex\n$vertexArray = new BasicVertexArray($glState, [3, 2]);\n</code></pre>","location":"user-guide/graphics/basic-vertex-array.html#creating-a-basicvertexarray"},{"title":"Understanding Vertex Layouts","text":"<p>The vertex layout array defines how your vertex data is structured. Each element in the array represents an attribute, and the value indicates how many floats that attribute contains:</p> <pre><code>// position only (vec3)\n$vertexArray = new BasicVertexArray($glState, [3]);\n\n// position (vec3) + texture coordinates (vec2)\n$vertexArray = new BasicVertexArray($glState, [3, 2]);\n\n// position (vec3) + normal (vec3) + color (vec4)\n$vertexArray = new BasicVertexArray($glState, [3, 3, 4]);\n\n// position (vec3) + texture coordinates (vec2) + normal (vec3) + color (vec4)\n$vertexArray = new BasicVertexArray($glState, [3, 2, 3, 4]);\n</code></pre> <p>The <code>BasicVertexArray</code> automatically calculates the stride (total bytes per vertex) and configures the vertex attribute pointers based on your layout specification.</p>","location":"user-guide/graphics/basic-vertex-array.html#understanding-vertex-layouts"},{"title":"Uploading Vertex Data","text":"<p>Once you've created a <code>BasicVertexArray</code>, you'll need to upload your vertex data to the GPU. This is done using the <code>upload()</code> method with a <code>FloatBuffer</code>:</p> <pre><code>use GL\\Buffer\\FloatBuffer;\n\n// create a buffer with vertex data\n$vertexData = new FloatBuffer([\n    // vertex 1: position (x, y, z) + texture coords (u, v)\n    -0.5, -0.5, 0.0,  0.0, 0.0,\n    // vertex 2\n     0.5, -0.5, 0.0,  1.0, 0.0,\n    // vertex 3\n     0.0,  0.5, 0.0,  0.5, 1.0,\n]);\n\n// upload the data to the GPU\n$vertexArray-&gt;upload($vertexData);\n</code></pre> <p>The vertex data must match your specified layout. For example, if you defined a layout of <code>[3, 2]</code>, each vertex must contain exactly 5 floats (3 for position + 2 for texture coordinates).</p>","location":"user-guide/graphics/basic-vertex-array.html#uploading-vertex-data"},{"title":"Rendering","text":"<p>The <code>BasicVertexArray</code> provides convenient methods for rendering your vertex data:</p>","location":"user-guide/graphics/basic-vertex-array.html#rendering"},{"title":"Drawing All Vertices","text":"<p>To render all vertices in the buffer:</p> <pre><code>// bind and draw all vertices as triangles (default)\n$vertexArray-&gt;drawAll();\n\n// or specify a different render mode\n$vertexArray-&gt;drawAll(GL_LINES);\n$vertexArray-&gt;drawAll(GL_POINTS);\n</code></pre>","location":"user-guide/graphics/basic-vertex-array.html#drawing-all-vertices"},{"title":"Drawing a Range of Vertices","text":"<p>To render a specific range of vertices, useful when you have multiple objects in a single buffer:</p> <pre><code>// draw vertices starting at offset 10, drawing 6 vertices\n$vertexArray-&gt;draw(10, 6);\n\n// with a specific render mode\n$vertexArray-&gt;draw(10, 6, GL_LINE_STRIP);\n</code></pre>","location":"user-guide/graphics/basic-vertex-array.html#drawing-a-range-of-vertices"},{"title":"Binding the Vertex Array","text":"<p>If you need to manually bind the vertex array without drawing:</p> <pre><code>$vertexArray-&gt;bind();\n// ... perform custom OpenGL operations\nglDrawArrays(GL_TRIANGLES, 0, $vertexCount);\n</code></pre>","location":"user-guide/graphics/basic-vertex-array.html#binding-the-vertex-array"},{"title":"Best Practices","text":"","location":"user-guide/graphics/basic-vertex-array.html#best-practices"},{"title":"Use Static Data When Possible","text":"<p>The <code>upload()</code> method uses <code>GL_STATIC_DRAW</code>, which tells OpenGL the data won't change frequently. This is optimal for most game assets like models and static geometry. If you need to update vertex data every frame, consider using a different approach or managing the buffer manually.</p>","location":"user-guide/graphics/basic-vertex-array.html#use-static-data-when-possible"},{"title":"Minimize State Changes","text":"<p>Binding vertex arrays and buffers has a performance cost. Organize your rendering to minimize how often you switch between different vertex arrays:</p> <pre><code>// good: group objects using the same vertex array\n$vertexArray-&gt;bind();\n$vertexArray-&gt;draw(0, 3);    // object 1\n$vertexArray-&gt;draw(3, 6);    // object 2\n$vertexArray-&gt;draw(9, 12);   // object 3\n\n// avoid: unnecessary switching between vertex arrays\n$vertexArray1-&gt;drawAll();\n$vertexArray2-&gt;drawAll();\n$vertexArray3-&gt;drawAll();\n</code></pre>","location":"user-guide/graphics/basic-vertex-array.html#minimize-state-changes"},{"title":"Match Layout to Shaders","text":"<p>Ensure your vertex layout matches your shader's input attributes. The layout array maps to OpenGL's location attributes in order:</p> <pre><code>// vertex layout: [3, 2, 4]\n$vertexArray = new BasicVertexArray($glState, [3, 2, 4]);\n\n// corresponding shader attributes\n// layout(location = 0) in vec3 a_pos;     // first [3]\n// layout(location = 1) in vec2 a_uv;      // second [2]\n// layout(location = 2) in vec4 a_color;   // third [4]\n</code></pre>","location":"user-guide/graphics/basic-vertex-array.html#match-layout-to-shaders"},{"title":"Resource Cleanup","text":"<p>The <code>BasicVertexArray</code> automatically cleans up OpenGL resources when destroyed. However, be mindful of object lifetimes to avoid holding references longer than needed, and the other way around.</p>","location":"user-guide/graphics/basic-vertex-array.html#resource-cleanup"},{"title":"When Not to Use BasicVertexArray","text":"<p>While <code>BasicVertexArray</code> is convenient for many scenarios, you should consider working directly with OpenGL when:</p> <ul> <li>You need non-float vertex attributes (integers, bytes, etc.)</li> <li>You require indexed drawing with element buffers</li> <li>You're implementing advanced rendering techniques like instancing (see BasicInstancedVertexArray for that)</li> </ul>","location":"user-guide/graphics/basic-vertex-array.html#when-not-to-use-basicvertexarray"},{"title":"See Also","text":"<ul> <li>BasicInstancedVertexArray - For instanced rendering with per-instance attributes</li> <li>Shaders - learn about shader management in VISU</li> <li>QuadVertexArray - A pre-configured vertex array for rendering screen-space quads</li> </ul>","location":"user-guide/graphics/basic-vertex-array.html#see-also"},{"title":"Shaders","text":"<p>VISU's shader system simplifies the process of loading, linking, and managing shaders in your application. It provides an easy way to set uniforms, handle <code>#include</code> directives, and manage shader defines. With this system, you can focus on creating stunning visual effects without getting bogged down in the details of shader management.</p>","location":"user-guide/graphics/shader.html"},{"title":"What is a Shader?","text":"<p>A shader in the context of VISU is the same as in OpenGL, it is a programmable code snippet that manipulates graphic rendering by taking control over specific stages within the graphics pipeline. Written in GLSL (OpenGL Shading Language), shaders are paramount for visual effects, ranging from simple changes in color to complex simulations like dynamic lighting or procedural texture generation.</p>","location":"user-guide/graphics/shader.html#what-is-a-shader"},{"title":"Autoloading Shaders","text":"<p>In a project created with <code>visu-starter</code>, the ShaderCollection object is set up in the <code>app/core.ctn</code> file. This object acts as a manager class to hold all shader objects.</p> <pre><code>@shaders: VISU\\Graphics\\ShaderCollection(@GL, :visu.path.resources.shader)\n    - enableVISUIncludes()\n    - addVISUShaders()\n    - scanShaderDirectory(:visu.path.resources.shader)\n</code></pre> <p>The configuration above performs the following actions:</p> <ol> <li>Enables all VISU includes, allowing you to include GLSL files provided by VISU itself.</li> <li>Adds the default VISU shaders to the collection.</li> <li>Scans your project's <code>./resources/shader</code> directory for <code>*.glsl</code> files.</li> </ol> <p>All files in the <code>./resources/shader</code> directory will be automatically loaded, compiled, and linked using the following line in your <code>Game.php</code>:</p> <pre><code>$container-&gt;resolveShaders()-&gt;loadAll(function($name, ShaderProgram $shader) {\n  Logger::info(\"(shader) loaded: {$name} -&gt; {$shader-&gt;id}\");\n});\n</code></pre>","location":"user-guide/graphics/shader.html#autoloading-shaders"},{"title":"Accessing Shaders","text":"<p>Shaders become available in your ShaderCollection by their filename. For example, if you have the following files:</p> <pre><code>resources/\n  shader/\n    background.vert.glsl\n    background.frag.glsl\n</code></pre> <p>You can access them using the following code:</p> <pre><code>$shaderCollection = $container-&gt;resolveShaders();\n$shader = $shaderCollection-&gt;get('background');\n</code></pre> <p>This makes it easy to manage and use shaders in your VISU project.</p>","location":"user-guide/graphics/shader.html#accessing-shaders"},{"title":"Manually Creating Shader Objects","text":"<p>While using the ShaderCollection is a convenient way to manage shaders, you can also create shader objects manually. This approach is completely valid if you prefer not to use the shader collection. However, note that you won't have the ability to use <code>#include</code> when creating shaders this way.</p> <p>To create a shader object manually, you'll need an instance of <code>VISU\\Graphics\\GLState</code>, which can usually be resolved from the container using <code>$container-&gt;resolveGL()</code>.</p> <p>Here's an example of creating a shader program with a simple vertex and fragment shader:</p> <pre><code>$shader = new ShaderProgram($glstate);\n</code></pre> <p>Which will create the shader program. Next, attach a simple vertex shader:</p> <pre><code>$shader-&gt;attach(new ShaderStage(ShaderStage::VERTEX, &lt;&lt;&lt; 'GLSL'\n#version 330 core\n\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec2 aTexCoord;\n\nout vec2 TexCoords;\n\nvoid main()\n{\n    gl_Position = vec4(aPos, 1.0);\n    TexCoords = aTexCoord;\n}\nGLSL));\n</code></pre> <p>And also attach a simple fragment shader:</p> <pre><code>$shader-&gt;attach(new ShaderStage(ShaderStage::FRAGMENT, &lt;&lt;&lt; 'GLSL'\n#version 330 core\n\nout vec4 FragColor;\nin vec2 TexCoords;\n\nuniform sampler2D u_texture;\nvoid main()\n{             \n    FragColor = texture(u_texture, TexCoords);\n}\nGLSL));\n</code></pre> <p>Finally, link the shader program:</p> <pre><code>$shader-&gt;link();\n</code></pre>","location":"user-guide/graphics/shader.html#manually-creating-shader-objects"},{"title":"Using / binding a Shader","text":"<p>To set a shader program as the current one in the OpenGL context, use the <code>use()</code> \ud83d\ude48 method on the shader program object:</p> <pre><code>$shader-&gt;use();\n</code></pre>  <p>Note</p> <ul> <li>Ensure the shader program is linked before calling <code>use()</code>, as it will throw a <code>ShaderProgramException</code> if the program is not linked.</li> <li>The <code>use()</code> method sets the shader program as the current program only if it's not already in use, avoiding unnecessary calls to <code>glUseProgram()</code> and improving performance. However, if you use <code>glUseProgram()</code> directly, the VISU shader system won't be aware of the change and won't track the current shader program.</li> </ul>","location":"user-guide/graphics/shader.html#using-binding-a-shader"}]}